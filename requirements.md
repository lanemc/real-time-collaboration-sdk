Great. I’ll write a comprehensive technical PRD for a Real-Time Collaboration Core SDK that supports web and mobile platforms (JavaScript/TypeScript, React, Flutter), uses OT under the hood, allows structured data and binary blobs, and targets collaborative documents, dashboards, and whiteboards. I’ll ensure the SDK offers flexible extensibility and includes adapters for common persistence backends.

I’ll get started and let you know when the PRD is ready for your review.

# Real-Time Collaboration Core – Technical Product Requirements Document

## Introduction

Real-Time Collaboration Core (RTCC) is a developer toolkit for adding **real-time collaborative editing and live data synchronization** to applications. It enables **“Google Docs”-style** concurrent editing and live shared data (e.g. dashboards, whiteboards) **without requiring deep expertise in OT/CRDT algorithms**. In today’s software landscape, users increasingly expect collaborative, multi-user experiences – _“real-time collaboration… isn’t just a trend… it’s here to stay”_. However, implementing real-time collaboration from scratch is notoriously complex. RTCC aims to **abstract away the hard problems of concurrency, conflict resolution, and networking**, allowing developers to easily turn single-user apps into multi-user, **“multiplayer”** applications.

**Target Audience:** This toolkit is aimed at **web and mobile application developers** (e.g. React or Flutter developers) who want to add collaborative features (co-editing documents, shared whiteboards, live synced data) to their apps but **lack specialized knowledge** in operational transformation (OT) or conflict-free replicated data types (CRDTs). By using RTCC, a developer can get out-of-the-box real-time sync and presence features with minimal code changes.

## Background & Problem Statement

Building real-time collaborative functionality is extremely challenging. The core difficulty lies in **keeping distributed state consistent** when multiple users make concurrent edits. Academic and industrial research over 30+ years has produced algorithms like **Operational Transformation (OT)** and **CRDTs**, but applying these correctly is tough. Even tiny mistakes can break the consistency guarantees – _“the smallest bug in a collaborative implementation can lead to divergence”_, causing documents to get out-of-sync and resulting in “nonsensical changes” for users. In other words, real-time collaboration is _“turtles all the way down”_ in complexity; every layer of solution introduces new corner cases.

Because of this complexity, **small teams often avoid implementing real-time collaboration altogether** or rely on limited third-party services. There is a **high barrier to entry**: one must deeply understand concurrency control algorithms or risk subtle bugs that are **hard to debug and can corrupt data state**. Joseph Gentle (engineer behind Google Wave’s OT and ShareDB) famously said: _“implementing OT sucks. There’s a million algorithms with different tradeoffs, mostly trapped in academic papers. The algorithms are really hard and time consuming to implement correctly. \[…] Wave took 2 years to write…”_. This illustrates why adding collaboration is often seen as an expert-only domain.

**Existing libraries and services have limitations:** Low-level libraries exist (e.g. **Yjs** for CRDT, **ShareDB** for OT), but using them still requires understanding the theory and integrating it properly. Developers must wire up networking, handle transforms, and sometimes sacrifice functionality. The **difficulty of these algorithms means even well-supported solutions can be misused**, leading to bugs or needing to restrict features. For example, Google Docs and most editors historically use OT for rich-text, but OT frameworks tend to be tailored to specific apps. CRDT-based frameworks like Yjs offer offline and peer-to-peer collaboration, but come with trade-offs such as more complex data structures and opaque storage formats for data. In practice, many developers end up using **proprietary services** (like Firebase Realtime DB or Firestore for basic sync, or paying for editor-specific collaboration cloud services) as a shortcut. These can introduce **vendor lock-in** and often aren’t flexible enough for arbitrary data or custom UIs.

In summary, **real-time collaboration is a highly desired feature that is hard to implement**. The lack of an easy, open-source solution means it’s “underexplored” except by well-funded companies or open-source experts. RTCC addresses this gap by providing a **general-purpose, easy-to-use collaboration engine** that developers can plug into their apps – effectively **democratizing Google Docs-like functionality** for any application.

## Existing Solutions and Why They Fall Short

Before defining RTCC’s requirements, it’s important to examine existing solutions and their shortcomings:

- **Operational Transformation (OT) Frameworks:** The majority of real-time collaborative editors (Google Docs, Etherpad, CKEditor, etc.) use OT algorithms for concurrency control. Open-source OT implementations like **ShareDB** (which powers the DerbyJS framework) allow real-time editing of JSON documents using a central server. However, these frameworks still demand significant effort to integrate. They often require a **central “source of truth” server** per document, custom client integration, and understanding of OT’s versioning and transformation mechanics. OT algorithms also have many variants; only a couple of proven approaches (e.g. Google’s server-based Jupiter OT, or algorithms with the TP2 proof) reliably avoid divergence. Implementing or even just correctly using these can be daunting for most developers. _“Existing OT frameworks are very tailored to specific requirements… implementing OT sucks”_ – in other words, they aren’t designed as simple drop-in modules for arbitrary apps.

- **CRDT Libraries:** In the last decade, CRDTs (Conflict-Free Replicated Data Types) have emerged as an alternative. Libraries like **Yjs**, **Automerge**, and **Fluid Framework** allow peer-to-peer or offline editing with automatic conflict resolution. CRDTs are attractive because they don’t rely on a central server to merge changes and can work offline then sync later. Yjs in particular exposes high-level shared data types (text, maps, arrays, etc.) that sync automatically. It has a rich ecosystem of connectors (WebSocket, WebRTC, etc.) and is used in many apps. **However, CRDT-based solutions come with trade-offs:** for simple text or JSON data they work well, but for **rich, structured content (e.g. complex rich-text with styling or hierarchical data)** they can lose the notion of user intent. This can lead to odd behaviors unless the application’s features are limited. For example, CRDTs treat each character or JSON field as independent, so something like splitting a text node for formatting might not preserve the intended structure. CRDT implementations also maintain state as binary logs or “blobs” that can be harder to integrate with existing databases or query. While **Yjs has proven CRDTs can be generalized** (it supports text, drawings, even 3D model state sync), many developers still find the concept foreign and the integration non-trivial. There’s also a performance overhead for large documents (due to metadata) and complexity in implementing undo/redo.

- **Editor-Specific and Proprietary Solutions:** Some rich text editors (like **CKEditor** and **TinyMCE**) offer real-time collaboration plugins, but these are usually **closed-source, paid services** or require using their ecosystem. For instance, TinyMCE had a Real-Time Collaboration plugin, and CKEditor has a collaboration server – both are proprietary. This means developers cannot extend or deeply customize them, and you’re tied to those editors. **Firebase/Firestore** (by Google) is another approach some use for “live data sync”: it provides realtime updates of database records. Firebase is great for simple shared state (last-write-wins updates), but it does **not handle complex concurrent edits** on the same document field gracefully (no OT or CRDT merging – conflicts can override data). It’s essentially a **general realtime database, not built-in collaborative editing**. Other cloud services like Ably’s **LiveSync**, AWS AppSync, or Pusher provide realtime pub-sub and data sync, but again, **they do not solve conflict resolution** – that burden remains on the developer or a higher-level library.

**Conclusion – Opportunity for RTCC:** There is clearly _demand_ for real-time collaboration (as seen with Yjs’s popularity – over 900k weekly npm downloads, and the ubiquity of collaborative apps), but **no mainstream, easy, open-source toolkit** that covers most use cases in a flexible way. Yjs comes close in the CRDT space, but developers who aren’t familiar with CRDT might hesitate, and some rich-text scenarios are challenging. OT-based solutions have decades of research behind them and align with how Google/Microsoft built their products, but there’s no widely-used open source OT toolkit beyond specific frameworks (ShareDB) or editor-specific implementations. **RTCC aims to combine the best of both worlds**: use the proven reliability of OT algorithms for consistency, but package it in a **developer-friendly SDK** with simple APIs (much like Yjs’s ease-of-use philosophy). It will be open-source and extensible, avoiding vendor lock-in and allowing the community to contribute and trust the code. By handling the “hard parts” internally, RTCC will let developers add real-time collaboration as a _feature toggle_ rather than a multi-year engineering project.

## Goals and Objectives

**Primary Goal:** Make it **as easy as possible for developers to add real-time collaborative functionality** to their web or mobile applications. The following key objectives define the product:

- **Simple Integration & API:** Provide a high-level API/SDK that abstracts the complexity of real-time sync. Developers should be able to treat a shared document or data structure _almost like a local one_, and the library handles syncing behind the scenes. _“Shared types that work just like normal data types, but sync automatically”_ is the experience to strive for. For example, a developer might create a `SharedText` object and use it like a regular string/textarea, or a `SharedMap` like a normal JSON object – with RTCC managing operational transforms, network communication, and updates under the hood.

- **Real-Time Collaboration Features Out-of-the-Box:** The toolkit will support multi-user concurrent editing on various data types with **automatic conflict resolution** (eventual consistency). If two or more users edit at the same time, the system ensures all users end up with the same result (no manual merges needed). By default, conflict resolution will be **sane and predictable** (e.g. for text, edits integrate in order; for fields in a map, last writer wins unless customized). The focus is on _eventual consistency with a smooth live experience_, as one would expect in Google Docs.

- **Multi-Platform Support (Web & Mobile):** RTCC should be available for **web (JavaScript/TypeScript)** and **mobile (Flutter/Dart)** out of the gate. Web support ensures usage in React, Angular, or plain JS apps, while Flutter support covers Android/iOS and even desktop via Flutter. The API design should be consistent across platforms so developers get a similar experience. (In the future, we may also consider native Android/iOS SDKs or other frameworks, but initially web + Flutter provides broad coverage.)

- **Flexible Architecture with Adapters:** Design the system to be **modular and extensible**. Developers have different needs – some might use our default cloud/service, others might want to self-host or integrate with existing infrastructure. RTCC will have clearly defined interfaces for **network transport** and **data persistence** so that it can work in various environments. We will provide **core adapters for the most popular scenarios** (e.g. a WebSocket-based client–server transport out-of-the-box, an adapter for popular databases for persistence, perhaps a peer-to-peer WebRTC adapter in the future). But if needed, developers can write custom adapters (for example, to use a custom signaling service or to plug into an existing auth system). This flexibility ensures the toolkit can be adapted from a small startup demo to a scalable production system.

- **Built on Proven Collaboration Algorithms (OT):** Internally, use **Operational Transformation** algorithms to handle concurrency. We choose OT because it has a long track record in rich-text editors and can preserve user intent in structured content. By using a **server-coordinated OT model**, we leverage a known reliable strategy: each client syncs with a central server that ensures a consistent ordering of operations (thus avoiding extremely complex multi-way transforms). This dramatically reduces the chances of divergent document state, as the server acts as the source of truth for integration. The algorithms and data types chosen should be **battle-tested** (e.g. based on known research or existing implementations) to minimize the risk of the “small bug” that could break consistency. The goal is _robustness_ – developers shouldn’t have to worry about the under-the-hood math failing.

- **Support for Multiple Data Types:** Enable collaboration on **structured data**, not just plain text. The core data models to support:

  - **Text Documents:** Collaborative text editing with character-level OT (inserts, deletes, formatting markers). This is critical for use cases like docs, notes, or message editing. Rich text (with bold, etc.) will be supported at least to the extent of preserving text content; full rich-text OT on a tree model is complex, but we aim to support basic rich text structure or at least make it extensible.
  - **Lists/Arrays and Maps (JSON-like data):** Developers should be able to sync data like shared lists (e.g. tasks in a to-do app) or maps/objects (key-value structured data, e.g. a config or a record). RTCC will handle operations like adding/removing list elements, updating fields, etc., in a collaborative-safe way. This covers use cases like shared whiteboards (shapes could be objects in a list), collaborative tables or forms, or live JSON data for a dashboard.
  - **Binary Blobs & Media:** The toolkit should not be limited to small text data. It will provide a way to include **binary content (images, files, etc.)** in the collaborative model. For example, users could collaboratively build a document that includes images or a design tool that includes uploaded graphics. While we won’t _diff_ binary data (no merging inside an image file, for instance), RTCC can coordinate the insertion and update of blobs (perhaps by uploading them to a storage service and syncing references/IDs in the shared document). The objective is to make including images or other media in collaborative documents straightforward for developers.

- **Presence and Awareness:** Provide built-in **presence indicators** and awareness features to enrich collaboration. This includes tracking **who is online** in a session and, for text content, showing **where each user’s cursor or selection is**. Presence greatly improves user experience (e.g. seeing that _“Alice is editing this paragraph”_ or a cursor with Alice’s name). RTCC will include an **awareness API** that broadcasts each user’s presence state (e.g. cursor position, user name, perhaps a user color or status) to others. Developers can easily tap into this to display collaborator cursors, user lists, or even a simple “user X is online” list. This presence module should be efficient (likely using a lightweight broadcast, separate from the main OT stream, since presence data is ephemeral and constantly updating).

- **Persistence and Offline Support:** Allow the shared data to be **persisted to a backend datastore** so that collaboration sessions can be saved and resumed. For example, if everyone disconnects, the document’s last state should not be lost – it can be loaded from a database the next time someone opens it. The toolkit will offer optional persistence hooks (e.g. writing operations or snapshots to an SQL/NoSQL database). For initial simplicity, we might store periodic snapshots of document state and a log of operations. This also enables **history/undo** features down the line. Regarding **offline support**: the initial focus is real-time online collaboration; fully robust offline editing (where multiple users go offline, edit, then merge later) is not in v1 scope (since our OT model requires a coordinating server). However, the client library should **gracefully handle brief disconnections** – e.g. queueing user operations and resyncing when reconnected. In the future, we can explore more advanced offline capabilities (perhaps via CRDT or hybrid approaches), but initially, “optional offline caching” (storing the doc in localStorage/IndexedDB for quick reload) and reconnect recovery is the goal.

- **Security and Access Control:** Provide mechanisms to ensure collaboration happens securely:

  - All network communication should be encrypted (e.g. using WSS or via HTTPS if polling) to protect data in transit.
  - The toolkit should integrate with application authentication/authorization – for instance, allow developers to specify which users can access a given collaborative document. We might not build a full auth system, but the server component can accept auth tokens or callbacks to validate that a user is allowed to join a document session. This is crucial for multi-tenant apps.
  - Consider **data privacy** features such as optional end-to-end encryption of document content. (With a central OT server, true E2E encryption is tricky because the server needs to see plain ops to transform them. However, we could allow encryption of content fields with the trade-off that conflict resolution still occurs on encrypted blobs – a complex area, likely a future enhancement. A note: CRDT would allow E2E easier by not requiring server to transform, but for now we stick to OT and assume server is trusted or self-hosted.)

- **Performance and Scalability:** Ensure the solution performs well for typical use cases:

  - **Low Latency:** Changes made by a user should propagate to others in near real-time (within tens of milliseconds over network latency). The architecture will use **push-based updates** (e.g. WebSockets) to achieve real-time delivery.
  - **Efficient Operations:** The data sync should send only minimal diffs (operations), not full document states, to conserve bandwidth. The OT algorithm should be optimized to handle fast typing (many ops per second) without bottleneck. For example, it may batch operations or compress multiple character inserts if needed.
  - **Document Size:** Support documents or data of moderate size (e.g. many pages of text or a JSON with hundreds of entries) efficiently. There should be no hard-coded small limits. We will test and optimize memory usage (possibly using techniques like compaction of history, etc.). Very large documents might degrade, but part of the toolkit’s guidance will be about practical limits.
  - **Concurrent Users:** Aim to support on the order of **dozens of concurrent collaborators** on a single document with good performance. (Google Docs has an upper limit around 100 concurrent editors for practicality). Our initial target can be \~10 active editors and 50+ viewers in a session without issues. The design should be able to scale further with optimizations.
  - **Scalability:** The server component should be horizontally scalable for many documents and sessions. Each document’s operations are coordinated through a single authority (to simplify OT), but we can run multiple server instances partitioned by document or user. We will design the server so it can be clustered or at least multiple docs can be handled independently. Additionally, because a central server is a potential single point of failure,, we will allow a persistence layer so a server crash doesn’t lose data, and possibly support failover to a backup server for high availability.

- **Open Source and Community-Friendly:** RTCC will be released under an open-source license (e.g. MIT or Apache) to encourage adoption. This also means we will emphasize **clear documentation** and examples, since the target is developers. We’ll provide guides for common integrations (e.g. using RTCC with React, or using it in Flutter) and reference applications (like a collaborative text editor demo, a to-do list demo, etc.). A developer should be able to get a basic collaborative feature working in their app in **hours, not weeks**.

## Non-Goals and Out of Scope

To clarify the focus, the following are **not in scope for the initial version** of RTCC:

- **Building Custom Editor UI Components:** RTCC is a backend/frontend data syncing toolkit, not a UI library. We will not create a full rich text editor component or drawing canvas ourselves – instead, we enable developers to connect their own UI to the collaborative data model. (We might provide lightweight bindings or examples for popular editors like ProseMirror, Quill, Slate, or for a Canvas whiteboard, but we won’t reinvent those UIs.) Our mission is to handle syncing and conflict resolution, _not rendering_; the developer remains free to use any frontend.

- **Complete Application Features:** We are not providing things like user management, project organization, or other app-level features that a full product like Google Docs or Figma has. RTCC is the _core engine_ only. For example, version history UI, comment systems, granular permissions, or track-changes features are out of scope (though our data layer might enable building those on top).

- **Fully Decentralized or Peer-to-Peer Collaboration (for V1):** While CRDT-based purely peer-to-peer collaboration (no server, fully offline-first) is exciting, our initial focus is on a server-mediated model (OT-based). We won’t deliver a P2P solution in V1. All clients will communicate through a server (or cloud service) for coordination. This simplifies the design and aligns with our OT choice. Similarly, **offline editing** where multiple clients independently edit for a long time and merge later is not guaranteed in V1 (beyond queuing brief disconnects). Our philosophy is to start with the simpler, known approach and later evaluate decentralized modes as a future improvement.

- **Supporting Unlimited Scale or Unbounded Data:** While we aim for good scalability (see above), we are not promising that a single document can be edited by hundreds of people at once with perfect performance, or that gigabyte-sized documents will sync flawlessly. There are practical limits given the consistency model. Likewise, extremely high-frequency data (e.g. real-time sensors updating 1000s of times per second) is not the target use case – our focus is human collaboration (typing speed, user actions). Integrating with IoT or as a general real-time database is out of scope.

- **Replacing Traditional Databases for Complex Queries:** RTCC’s data is optimized for synchronization and collaboration, not complex querying or reporting. For instance, while we will allow persisting the collaborative data, we don’t aim to be a fully queryable database or provide complex query APIs on the synced data. If a developer needs to, say, run analytics or search on the content, they might need to export or index it separately. (This is similar to how CRDT state can become an opaque blob – our focus is live sync, not data analytics.)

- **Absolute Consistency in All Conflict Scenarios:** Our eventual consistency model guarantees all users see the same final state **given the operations processed**. However, we are not implementing domain-specific conflict resolution beyond the generic strategies. For example, merging two simultaneous edits in text is straightforward (both insertions will appear), but merging two different simultaneous edits to the same field in a JSON object will by default result in one winning (last-writer-wins). We won’t attempt to intelligently merge, say, two paragraphs of prose or resolve semantic conflicts – that’s beyond the scope of a generic toolkit. Developers should be aware of logical conflicts in their specific app domain (we provide the tools to avoid _data_ conflicts, but not higher-level intent conflicts beyond what OT/CRDT can do).

- **Strong Real-Time Collaboration for Non-Document Media:** For things like **real-time concurrent multimedia editing (audio/video)** or **real-time gaming state sync**, those have specialized needs (latency demands, etc.) which are outside our focus (though basic game state could use our JSON sync). RTCC is primarily aimed at document-like or data-structure collaboration, not high-frequency physics updates or media streaming.

By clarifying these non-goals, we ensure RTCC’s development stays focused on its core value: **making standard collaborative editing/sync trivial to implement**, rather than boiling the ocean of all real-time sync problems.

## Use Cases and Examples

RTCC will enable a variety of use cases across different application types. Some examples include:

- **Collaborative Document Editing (Google Docs clone):** A web app that allows multiple users to edit the same rich text document simultaneously. Using RTCC, a developer can turn a plain text editor into a collaborative one. Each user’s keystrokes appear in real-time on others’ screens, and cursors or text selections are highlighted in each person’s name color. For instance, two people can jointly write a project proposal in the same editor, with no fear of overwriting each other’s changes. Presence indicators show who is currently in the document and where they are editing.

- **Team Whiteboard or Drawing Canvas:** An application for creative brainstorming or diagramming (think Figma, Miro, or Google Jamboard style). Users can draw shapes, add text boxes, or sketch on a shared canvas concurrently. RTCC can sync the underlying shape objects (as a list of elements with properties like position, color, etc.) in real-time. When one user moves or edits a shape, everyone sees it update live. The presence feature could show each user’s cursor or pointer on the canvas. Developers can build this by representing the whiteboard state as a shared JSON structure (e.g. an array of objects for each shape) and let RTCC handle the merge of changes like “User A added a post-it note” while “User B moved a rectangle”.

- **Live Data Dashboards and Spreadsheets:** Imagine a collaborative dashboard where multiple users can tweak parameters or edit cells in a spreadsheet and everyone sees updates instantly. With RTCC, the data backing a dashboard (like a JSON of metrics or a table) can be made collaborative. For example, in a budget planning app, two users could be filling different parts of a spreadsheet at the same time, or one person adjusts a filter and the charts update for all viewers in real-time. The toolkit ensures that if two people edit the same cell, one version wins deterministically, and no update is lost – and importantly, that the UI reflects changes immediately. Similarly, for live dashboards, if one user changes a value or a dataset, all connected clients sync up without manual refresh.

- **Multiplayer To-Do or Note Apps:** Many personal productivity apps (to-do lists, note-taking, calendars) are more powerful when collaborative. Using RTCC, a developer can create, for example, a **shared to-do list** app where family members or teammates edit the list together. Tasks could be represented as a shared list data structure; when someone checks off or edits a task, everyone online sees the update instantly. Conflict resolution ensures two people adding tasks simultaneously or reordering the list doesn’t cause errors – the operations will be merged consistently. Presence could even show an icon next to a task if someone is currently editing it.

- **Co-browsing and Form Filling:** In customer support or collaborative form filling scenarios, RTCC could be used to sync form field data between users. For example, a support agent could help a customer fill a form by seeing the customer’s entries in real time and adding suggestions. Each input field could be a shared text object. Both parties’ edits sync, and you might lock a field when one is actively typing to avoid confusion (the toolkit can support such patterns, though locking is handled at the application level if desired).

- **Code Collaboration and Education:** A lightweight code editor in a browser (or an educational coding platform) where a mentor and a student can write code together concurrently (similar to VSCode Live Share or CodePen Collab mode). RTCC can handle the text sync for the code (and even JSON data for things like shared cursor position or annotations). This could be extended to multi-user debugging sessions or pair programming tools.

These examples illustrate how RTCC’s core features – shared data types, OT-based merging, and presence – can be applied broadly. In each scenario, the **developer’s effort is greatly reduced**: instead of building a custom syncing protocol or worrying about edge cases of merging changes, they simply use the RTCC API to create a collaborative object (text, list, etc.), and then build their UI on top of it as usual. The toolkit manages distributing every change to other clients in real time, so the developer can focus on the app’s functionality and user experience.

## Solution Overview and Architecture

To achieve the above goals, the Real-Time Collaboration Core will consist of a **client-side SDK** (for web and for Flutter) and an optional **server component** that coordinate to manage collaborative state. Below is an overview of the architecture and key components:

**High-Level Architecture:**

- **Client SDK (Web & Mobile):** This is the library developers include in their application. It provides the API for creating and manipulating shared data structures. Internally, it manages a **local copy of the shared state**, listens for user-generated changes (edits), and sends operations to the server. It also receives operations from other collaborators (via the server) and applies them locally, updating the application’s state. The client SDK will be implemented in TypeScript for web (transpiling to JavaScript) and in Dart for Flutter. The two implementations will follow the same logical design (possibly sharing core algorithm ideas, or even code via Rust/WASM in the future, but initially likely separate language ports). The client is responsible for **operational transformation on incoming operations**, integration of remote ops with local state, and emitting events to the app (so the UI can re-render or update cursors, etc.).

- **Real-Time Collaboration Server:** A server (or cloud service) that acts as the **central coordinator** for operations in OT. In the default setup, all clients editing a given document/session will connect to this server (likely via WebSockets). The server’s role is to:

  - Receive operations from clients, assign a sequence/order (and possibly a version stamp).
  - Perform necessary **transformations** of operations if concurrent edits arrived. In our OT model, the server will typically buffer and sequentially integrate ops, sending back transformed ops to clients as needed to ensure everyone applies them consistently.
  - Maintain the authoritative state of each shared document/data (this can be in-memory and/or persisted). The server essentially holds the truth of the document at the latest version and a log of operations.
  - Broadcast new operations (or the results of operations) to all connected clients of that document so they can update their local copy.
  - Manage client sessions (join/leave) and possibly basic access control (checking if a user is allowed to subscribe to a given doc).

  This server can be run by the developer (self-hosted as part of their app backend) or potentially provided as a managed cloud service (if we offer a hosted option). Since we use a server-based OT, **each document collaboration is essentially a star topology** – clients sync through the server, not directly to each other. This simplifies the algorithm (no multi-way transforms on clients) and avoids many edge cases.

- **Network Transport:** By default, we will use **WebSocket** for bi-directional, low-latency communication between clients and server (with fallback to HTTP long-poll if needed for older environments). The SDK will include a WebSocket adapter for the transport layer. However, thanks to the adapter architecture, the transport can be swapped out. For example, a developer could use a **Custom Transport Adapter** to run on top of an existing messaging system (MQTT, Ably, Firebase channels, etc.) if they desire, as long as ordering of messages per document is preserved. The protocol we define over the transport will include messages for: connecting (auth handshake), joining a document room, submitting an operation, acknowledging and broadcasting operations, and presence updates.

- **Data Model & OT Algorithm:** At the heart is the representation of shared data and the OT logic. We’ll define a set of **shared data types** that developers can use (text, map, list, etc. as described earlier). Each type has a well-defined format for operations (for example, a Text operation might be "insert 'hello' at position 5" or "delete 3 characters at position 10"). For each type, we implement the necessary **transformation functions** that can take two concurrent operations and produce equivalent operations that can be applied in a different order yielding the same result. The **operational transformation engine** on client and server ensures that when operations are applied out of order, they are transformed appropriately. We will utilize the standard approach of **version vectors** or **incremental revision numbers**: each document has a version number (or state ID), and operations carry the version they are based on. The server, upon receiving an operation, transforms it against any operations that have been integrated since that base version, then applies it. It sends back the transformed operation (or a confirmation) to the originating client and broadcasts either the same or transformed op to others.

  - _Example:_ User A and User B both type a character at the same time in a SharedText at slightly different positions. Each client sends an insert operation with the base version N. The server receives A’s op first, applies it (document now version N+1). When B’s op arrives (with base N), the server transforms B’s insert position by +1 (because A inserted something before B’s position). It then applies B’s op as version N+2. Both ops are broadcast to all clients. A’s client might get B’s op (transformed if needed relative to A’s), and B’s client gets A’s op (which the server could also send with a transform relative to B’s view). Each client applies these and ends up with the same text content. This all happens in milliseconds.

  We will likely base our OT algorithms on known correct models (for example, adopt or adapt the **Jupiter OT algorithm** used by Google Wave, or the **ShareJS/ShareDB OT types** which are proven in production). By not inventing from scratch, we leverage existing research to ensure we satisfy the **TP2 conditions** (the properties needed to avoid OT inconsistencies). The server-based transformation inherently avoids multi-way conflicts by serializing operations via the server.

- **Shared Data Types Detail:**

  - **SharedText** – sequence of characters. Ops: insert(characters, position), delete(numChars, position). These ops are transformed based on index shifts. We’ll support basic string operations and potentially attributes for rich text (like "apply bold to range"). Rich text OT may be more complex (often modeled as a separate structure or multiple text segments); initially we might just support plain text or very basic formatting marks.
  - **SharedList** – an ordered list of elements. Ops: insert(element, index), delete(index), maybe move(index, newIndex). List OT will handle index shifts similar to text (if two people insert at same index, one will end up either before or after based on an arbitrary but consistent rule, e.g. tie-break by user ID).
  - **SharedMap / SharedObject** – a JSON object (key-value store). Ops: set(key, value), remove(key), maybe update (key, newValue) which is essentially set. Concurrent sets to different keys don’t conflict; sets to the same key – we may choose last-writer-wins by default, or optionally could flag it. Since OT requires transforming operations, and two set ops on the same key cannot really both be applied (one will override), our transform can be simple: decide an order (again possibly by timestamp or user priority) and that becomes final. We will document this behavior.
  - **SharedBinary / File** – to handle binary blobs, rather than byte-level OT (which is not feasible for large files), we will provide a mechanism for **attaching binary data**. One approach: the binary file (image etc.) is stored outside of RTCC (e.g. uploaded to a cloud storage or sent directly to the server), and RTCC shares a reference (like a URI or an ID) in a SharedMap or SharedList. We will include a utility to facilitate this: e.g. an API like `sharedMap.attachFile(key, file)` which under the hood uploads the file via a provided adapter (could be a simple REST endpoint or cloud storage) and then inserts the file’s reference into the shared data so others get it and can download the file. While somewhat out-of-band, this makes binary distribution reliable without clogging the OT channel. For small binaries (say an avatar image encoded in base64), the developer _could_ directly put the base64 string in a SharedText or SharedMap value, and it would sync, but we will recommend the attach mechanism for efficiency.

- **Presence/Awareness Module:** Each client will have a sub-component for **presence**. When a user joins a session, the server keeps track of the active participants for that document. The client SDK will expose something like a `presence` object or events. For example, `collabSession.on('presenceUpdate', callback)` or a way to query the list of users currently editing. Additionally, for text editing, the SDK will expose an API for **cursor syncing**: the app can tell RTCC the user’s current cursor/caret position or selection range, and RTCC will broadcast that to others (likely throttled, e.g. 5-10 times per second to avoid flooding). Other users’ clients receive these and can render ghost cursors. We might implement presence as a simple shared state that doesn’t go through OT (since it’s transient and doesn’t need conflict resolution – last update wins is fine). In fact, Yjs uses a separate “Awareness CRDT” for this purpose. In our case, we can do simpler: each client periodically sends a small presence message (with their user ID, cursor position, etc.) that the server echoes to others. This data is not part of the document state; it resets when someone leaves. The server could maintain a map of user -> presence data for each session and update on changes. The **SDK will make it easy to broadcast and subscribe to presence** so developers can focus on visualizing it (e.g. rendering colored cursors or showing “User X is online” in UI).

- **Persistence Layer:** The server will be designed to optionally connect to a **database for persistence**. In memory, the server will hold the current state of each document and a backlog of operations (for transforming new ones). For durability and for new participants joining, we should allow storing data. We have a few strategies:

  - **Snapshot and Log:** The server can take periodic snapshots of the full document content (e.g. after every N operations or every T minutes) and store them in a database. In between, it can store the incremental ops in a log. New clients joining could either get the latest snapshot (fast to load large doc) plus tail of ops, or the server can simply send the current state from memory (since it has it). The DB ensures if the server restarts, it can recover state.
  - **Direct Operation Storage:** Alternatively, the server can apply ops to a backend store in real-time (for example, update a MongoDB document for each op). But doing so transactionally for each keystroke might be heavy; likely we prefer the above approach and maybe flush to DB on disconnect or on snapshot events.
  - **Pluggable DB adapters:** In spirit of flexibility, we can provide an interface for persistence and maybe out-of-box support for a couple of popular systems (e.g. an adapter for PostgreSQL or Redis or Mongo). Simpler still, we could start with a file-system or in-memory default (for quick start) and let developers plug in a real DB if needed. The PRD’s goal is to ensure we consider persistence, so devs don’t have to write their own sync to database if they want data saved.

- **API Design (Developer’s Perspective):** While implementation details matter, the success of RTCC lies in how easy and intuitive the API is:

  - On **Web/JS**, likely we will have an initialization where the developer connects to the collaboration service (providing e.g. server URL and authentication token if any). For example: `const collab = new RTCC.Client({ serverUrl: "wss://collab.myapp.com", authToken: userJwt });`.
  - Then a method to **open or create a shared document/session** by an ID: `const doc = collab.openDocument("documentId", initialData, schema)`. The `schema` could specify what type of data (text, map, etc., or a composite). If the document already exists on server, it syncs and populates the local state; if not, it uses provided initialData to initialize it.
  - The returned `doc` (or separate objects from it) allows the developer to **interact with the shared data**. For instance, if the doc is a text: `doc.insertText(pos, "hello")`. Or if it’s a map: `doc.set("title", "New Title")`. We will also support applying changes by binding to UI events. For example, in a textarea element, the developer can on every keypress update the SharedText, or use two-way binding if in a reactive framework.
  - The SDK should also provide **events or reactive subscriptions**. E.g. `doc.on('update', callback)` whenever any remote change comes in (or even local changes, after applied). In React, we might offer a hook: `const [textValue, textDoc] = useSharedText(docId)` which under the hood opens the doc and gives you state that auto-updates (triggering re-renders).
  - **Flutter** might use a similar approach with a `ChangeNotifier` or `Stream`. Perhaps `RTCCFlutter.openDocument(id)` returns an object that you can listen to for changes and bind to your UI with `ValueListenableBuilder` or stream subscription.
  - **Presence API:** Possibly `doc.presence.getUsers()` to get current online users, and events like `doc.on('userJoined', user => …)`. For cursors, if `doc` is text, maybe `doc.updateCursor(position)` to broadcast my cursor, and an event `doc.on('cursorUpdate', (userId, position)=> …)` for others.
  - We want the API to feel **natural and minimal**. If possible, hiding even the concept of operations from the developer. They work with the state, and we handle the diff. (However, for performance it’s often better to explicitly call insert/delete methods rather than setting entire text value, to avoid generating big diffs – this can be explained in docs).
  - **Adapters & Extensibility:** The configuration when initializing can allow plugging different modules. For example: `new RTCC.Client({ transport: new RTCC.WebSocketTransport(url), storage: new RTCC.PostgresAdapter(connectionString) })`. If using our provided defaults, developer might not have to specify anything except server URL. For a peer-to-peer future adapter, it could be `transport: new RTCC.WebRTCTransport(...)`. The same goes for integrating with different frameworks; e.g. if a developer is using an existing rich text editor like Quill, we might provide an adapter that binds a SharedText to Quill’s delta operations.

- **Security Considerations:** The server will be built with security in mind. For each incoming connection, it should authenticate the user (likely via a token that the developer’s backend issues – e.g. JWT or session ID). We won’t mandate how authentication happens but will allow a hook (so the server can call a provided function or verify a token signature with a secret). This ensures only authorized users can join a given doc. We’ll use document IDs or room IDs that are unpredictable (e.g. UUIDs) to avoid guessing. Also, within the protocol, we will validate operations – a client should not be able to, say, inject an operation that violates the document schema or size limits (server will perform checks to prevent malicious or malformed ops from crashing the system). If we provide a hosted version, we’ll enforce rate limits to prevent abuse (like a user spamming huge ops).

With this architecture, a typical flow might look like:

1. **Initialization:** App loads, developer’s code initializes the RTCC client SDK (pointing it to the collab server and passing an auth token).
2. **Joining a Document:** The app calls to open a document or session by ID. The RTCC client connects via WebSocket to the server, authenticates, and subscribes to that document’s updates.
3. **State Sync (Handshake):** The server sends the current state of the document (or a diff from a known version) to the client. The client merges this into its local empty state. Now the local state is up-to-date. The client also receives info on any other users currently in the session (for presence).
4. **Real-Time Editing:** The user makes a change (e.g. types a character, or toggles a checkbox). The app code calls RTCC’s API (e.g. `insertText` or `setField`). The RTCC client captures this as an operation (with the current version number), immediately applies it to the local state (optimistically, so the UI updates instantly), and sends the operation to the server asynchronously.
5. **Server Integration:** The server receives the op. It checks the op’s base version vs the current version. If current is newer, it means there were other ops in between – so the server will transform the incoming op against those to align it. Then the server applies the op to its master state, increments the version, and sends an acknowledgment or the transformed op back to the client (so the client can adjust if needed, e.g. if its optimistic update needs correction, though in many cases the client might have used the same transform logic to apply optimistically).
6. **Broadcast:** The server broadcasts the operation (or the resulting change) to all _other_ clients in the document. Those clients receive the op, transform it against any local in-flight ops they might have, then apply it to their state. The SDK triggers update events, and the UI in those apps updates to reflect the change.
7. **Continuous Sync:** This cycle repeats for every edit. Because of OT, even complex interleaving of changes will resolve to a consistent end state for everyone.
8. **Presence Updates:** When a user moves their cursor or starts typing, their client sends presence messages (e.g. “cursor at position 100 for user X”). The server relays these (possibly batched) to others. The client SDK then emits events like “user X cursor changed” which the app uses to show the cursor moving. If a user disconnects, the server informs others that user left (so we remove their presence indicators).
9. **Persistence:** If configured, the server writes down the ops or new state to a DB so that if the document is reopened later or if the server restarts, no data is lost. If a new user joins late, the server might send a snapshot from persistence rather than needing someone else to be online with the data.

**Illustrative Diagram (conceptual):**

```
Users (Clients)        <---- WebSocket ---->     Collaboration Server     <----> Database (optional)
[ Browser running RTCC SDK ]    (Ops/messages)        [ Node.js process ]          [ e.g. Postgres/Mongo ]

Client A (React app)  --\
                         \__ (doc1 operations) __   [Doc1 OT Engine] --- persists --> [doc1 state/ops]
Client B (React app)  --/             |
                                      |             [Doc2 OT Engine] --- persists --> [doc2 state/ops]
Client C (Flutter app) --\__ (doc2 operations) __|
Client D (Flutter app) --/
```

In the above, the server manages multiple documents (each with its own OT engine instance and state). Clients A and B are collaborating on document 1, clients C and D on document 2, etc. Within each doc’s context, the server ensures all ops are ordered and transformed correctly. The clients maintain their own local copies in sync via the server.

## Technical Details and Requirements

This section enumerates specific technical requirements and design decisions for the RTCC project:

### 1. Client-Side SDK (Web – JS/TS)

- **Language:** TypeScript (output to JS for distribution). This ensures type safety for development and ease of use for JS developers.

- **Compatibility:** Should work in all modern browsers (via WebSocket). Also should work in Node.js environments (so developers could use it in Electron apps or server-side node if needed).

- **Packaging:** Provide as an npm package (`@lanemc/core` perhaps), which can be imported into React, Vue, Angular, etc. The core should have no dependencies on specific frameworks (framework-specific bindings can be separate add-ons).

- **Core Classes:** likely classes like `CollabClient`, `SharedDocument` (generic), and specific data type classes or methods to manipulate them. Also possibly `CollabPresence` for presence data.

- **Threading:** JavaScript is single-threaded; the OT transformations and incoming message handling will run on the main thread. We should ensure these operations are efficient to avoid UI jank. If heavy computation is needed (unlikely except maybe applying 1000 ops at once when catching up), consider using Web Workers in the future for offloading.

- **Example API usage (Web):**

  ```js
  import { CollabClient } from "@lanemc/core";
  const client = new CollabClient({
    serverUrl: "wss://collab.myapp.com",
    token: userToken,
  });
  const doc = await client.openDocument("doc-123", {
    type: "text",
    initialValue: "Hello",
  });
  doc.on("update", (newVal) => {
    renderEditor(newVal);
  });
  // On user typing:
  editor.onInput((change) => {
    doc.insert(change.position, change.text); // for example
  });
  ```

  The above pseudo-code would handle connecting and syncing a text document. Real API may differ but should be as straightforward.

- **State management:** The SDK should maintain the current document state and also possibly the **operation buffer** for any locally generated ops that are not yet acknowledged (to support undoing if needed or rebasing if server responds with a different context). We’ll implement a small state machine to handle cases like: connected vs disconnected, resyncing (on reconnection, need to get latest state and perhaps resend un-acked ops with transforms).

- **Testing:** We will create automated tests for the client that simulate multiple client instances editing and ensure they converge to the same state. This will involve a lot of unit tests for the transformation functions.

### 2. Client-Side SDK (Flutter – Dart)

- **Language:** Dart (to integrate seamlessly with Flutter apps).
- **Architecture:** The Flutter SDK will mirror the web SDK’s structure and API as much as possible, but implemented in Dart. We might utilize platform-specific APIs (like using Dart’s `WebSocket` support for networking).
- **Flutter Integration:** Provide idiomatic Flutter constructs: e.g. a `ChangeNotifier` or `Stream` that Flutter widgets can listen to for updates. For instance, a `CollabDocument` class could extend `ChangeNotifier`, so developers can use it with `ValueListenableBuilder` to rebuild UI on changes.
- **Example API usage (Flutter):**

  ```dart
  final collabClient = CollabClient(serverUrl: "wss://collab.myapp.com", token: userToken);
  CollabDocument doc = await collabClient.openDocument("doc-123", SharedText(initialValue: "Hello"));
  // Bind to UI
  AnimatedBuilder(
    animation: doc, // if doc is ChangeNotifier
    builder: (context, _) {
      return Text(doc.text); // current text value
    },
  );
  // On user input (e.g. using a TextField controller)
  doc.insert(position, text);
  ```

  We will refine the API to be friendly for Flutter developers, possibly providing some widgets or controllers for common cases (like a TextEditingController that syncs via RTCC).

- **Platform:** Flutter can deploy to mobile (iOS/Android), web, desktop. Our SDK should work on all, which implies we should use pure Dart and not rely on platform-specific code. The main concern is the network – we might need conditional logic since on web, Dart’s WebSocket uses browser APIs, whereas on mobile/desktop it uses its own. We will ensure the networking layer is abstracted so it works in all Flutter targets.
- **Testing:** Similar to web, we will write tests in Dart that simulate multiple docs and ensure consistency. Possibly we can reuse some logic by writing the core in a language-agnostic way (like if we had a shared Rust core, but that might be too complex initially). Instead, we may cross-verify by running parallel scenarios in JS and Dart to ensure they behave identically.

### 3. Server Component

- **Implementation Language:** Likely Node.js (JavaScript/TypeScript) for ease of sharing code with client and using existing OT libraries if any. Alternatively, a language like Go or Rust could be considered for performance, but that adds complexity for users to host. Starting with Node.js makes it approachable and we can later optimize if needed.
- **Real-time Framework:** Use a WebSocket library (e.g. `ws` in Node or socket.io). Since we might want custom protocol and efficiency, a simple WebSocket server with our own message format (JSON or binary) is suitable. We will handle subscription by document, etc.
- **Data Structures:** The server will maintain a dictionary of active documents (document ID -> document state + history). Each document state includes:

  - Current content (could be as a native JS object/string or as our internal model).
  - Operation log or at least a version counter and a list of recent ops not yet incorporated by all.
  - A queue of incoming ops if needed.
  - Metadata like connected users.

- **Operational Transform Implementation:** We might use existing OT libraries for base types. For example, ShareDB’s `json0` type (for JSON OT) and `text0` type (for text OT) are open-source. We could either use them directly or port their logic. Alternatively, use differential synchronization algorithms or any proven approach. Key is to ensure correctness (pass known OT transformation test cases).
- **Scaling Considerations:** Initially, the server can be a single process managing multiple docs. We should design with potential **sharding** in mind – e.g. using document IDs hashed to different processes or machines. If a single doc has to live on one server (due to centralized OT), horizontal scaling is achieved by splitting docs among servers. We might not implement multi-node coordination in v1, but our data persistence could allow multiple stateless server instances connecting to the same DB and coordinating via DB or a message bus. Possibly out of initial scope, but good to note for design.
- **Failure Recovery:** If the server restarts or crashes, we should not lose data. That’s why persistence is important. Also, clients should be able to reconnect. We’ll implement a reconnection logic: the client, on disconnect, will attempt to reconnect with exponential backoff. On reconnection, it might do a fresh sync (get latest doc state and reconcile with any un-synced local changes via transform).
- **Server API:** The server might also expose some REST endpoints or admin interfaces, for example to fetch a document state directly or to manage sessions (like kicking a user, or checking health). This isn’t core to PRD, but as a product, consider if an admin UI or debugging interface is needed for developers. At least, logging and monitoring features should be available (to track latency, conflicts resolved, etc., for troubleshooting).
- **Security on Server:** As discussed, verify auth tokens on connection. Also, isolate documents – one user shouldn’t get data from another doc they didn’t request. Possibly implement permission checks if the application wants (like read-only vs edit roles, though that might be left to app logic by not sending certain ops from read-only users).

### 4. Algorithms and Conflict Resolution Details

- We commit to **Operational Transformation (OT)** as the underlying technique for conflict resolution. Specifically, **server-based OT** (each client transforms operations relative to a centralized sequence) to avoid complicated multi-way transform issues. This means the server effectively serializes operations, applying them one at a time in some order, with transformation to account for concurrency.

- **Transform Function Requirements:** For each data type, define the transform of operation A against operation B (and vice versa if needed) such that applying A then transformed B yields the same result as applying B then transformed A. We will follow existing designs:

  - For text: The classic pair of transform functions for insert/insert, insert/delete, delete/delete, etc. Edge cases like two inserts at same position – we can break ties by ordering (e.g. operation with smaller timestamp or a unique client ID sort earlier or later). This ensures consistency in character ordering (we could also assign unique IDs to inserted characters similar to CRDT but within OT we usually rely on ordering by when received by server).
  - For list: analogous to text since list index is like character index.
  - For map/object: If two ops set the same key concurrently, one will overwrite the other. We may decide that the later op (in server receive order) wins and the earlier is effectively transformed out (i.e. loses). We should document this behavior. Perhaps we could allow a mode or callback for the developer to handle such a conflict (but that adds complexity; initially, last write wins is acceptable default).
  - Transforming a delete vs an insert on list: if A deletes an item that B inserted or vice versa, order will decide outcome (e.g. if delete comes after insert in timeline but was concurrent, maybe it deletes the inserted item or if before, then the insert index might shift).
  - These specifics will be based on prior art (we can reference ShareDB's JSON OT spec for guidance).

- **Ensuring No Divergence:** We will incorporate known correctness conditions (like **TP2** – Transformation Property 2) in our algorithm design. Only a few algorithms fully meet these conditions; by using a central server, we simplify the requirement (as per Ressel’s approach or later OT works). We will test with scenarios known to break naive algorithms. The product must inspire confidence that using it won’t result in the dreaded split-brain document issue. TinyMCE’s team, for example, evaluated CRDT but stuck with OT because it was a _“very complex but known feasible approach”_ with less risk of unsolvable issues. We take the same conservative approach.

- **CRDT Consideration:** Though we are using OT, we should mention our awareness of CRDT for future. CRDT is _“the holy grail of collaboration… with peer-to-peer editing and end-to-end encryption”_, but it’s _“not ready for our needs yet”_ in terms of full rich editing. That said, our architecture (with modularity) could later incorporate a CRDT mode or data type if we choose (for example, we could have an experimental `SharedTextCRDT` that works server-less). This won’t be in initial release, but we keep the door open. If we get significant interest in offline capability, a future version might support a hybrid approach (where if all clients disconnect, one can still edit offline and sync later with some merge workflow).

### 5. Example Scenario Walkthrough (Technical)

To ensure all requirements are clear, here’s a detailed walkthrough of a typical collaborative editing session using RTCC, covering technical aspects:

- **Scenario:** Two users (User1 on Chrome, User2 on a Flutter mobile app) are collaboratively editing a recipe document together. The document has a title (text field), an ingredients list (list of text items), and a preparation section (rich text). They can also insert images of the dish.

- **Setup:** The developer has chosen to represent the recipe document as a composite of shared types: e.g. a SharedMap with keys `"title"` (SharedText), `"ingredients"` (SharedList of Text), `"prep"` (SharedText), `"images"` (SharedList of image objects). They use the RTCC SDK to create/open this document by ID.

- **Joining:** User1 opens the recipe; their client connects and receives the current state (say the recipe already has title and some ingredients). User2 then opens it; now both are connected and the server tracks both in the session. Each sees that another user is present (presence API gives each one a user list containing User1 and User2).

- **Concurrent Edits:** User1 starts editing the title text (e.g. correcting a typo), while User2 concurrently adds a new ingredient to the list.

  - User1’s app, on text change, calls something like `doc.get("title").insert(position, "x")` for each character typed. The client packages these as operations (could batch a few characters, or one by one) and sends to server with the current version. Suppose the title was at version 5 and User1 inserts "Sugar" at pos 10, the op is `(baseVer=5, op=Insert("Sugar",10))`.
  - At the same time, User2’s app calls `doc.get("ingredients").insert(index, "Salt")` to add an item to ingredients. That becomes an op `(baseVer=5, op=ListInsert("Salt", index=3))`.
  - The server might receive User1’s op first. It applies the text insert to the title (version becomes 6). It then receives User2’s op with baseVer 5, but now server’s current version is 6. It knows one operation has happened since 5 (User1’s). It will **transform** User2’s op if needed. In this case, User1’s op was on a different field (`title` vs `ingredients`), so likely these ops don’t conflict at all. The server can safely apply User2’s insert (ingredients list now has "Salt"). Now version is 7.
  - The server sends out to User1: the ingredients insert op (so their UI can show the new "Salt" item). It sends out to User2: the title text insert op (so their UI sees the updated title). If either op had needed transformation (e.g. if both edited title at same position), the server would send the transformed version to ensure consistency.
  - Both clients apply the incoming ops via their SDK. The recipe state on both now includes the new title content and the added ingredient.
  - Meanwhile, presence: If User1 selects some text or is editing the title, User2 might see a cursor indicator on the title field with User1’s name. This happens because User1’s client continuously sends cursor position updates as they type, and the server relays to User2.

- **Image Insertion:** Now User1 wants to add a photo. They use the app’s UI to choose an image file. The developer has integrated RTCC’s binary attachment API, so the app calls something like `doc.get("images").attachFile(fileObject)`. The SDK might do: upload the file (maybe to the collab server or a configured S3 bucket) and get back a file ID or URL. Then it creates an operation to insert an image reference into the SharedList `"images"` (e.g. `ListInsert({id: <fileID>, caption:""}, index)`).

  - The server receives this op, applies it (now the images list includes that image entry). It broadcasts to all. User2’s client receives it, sees a new image ID in the list, and triggers the UI to load/display that image (likely using the URL).
  - If both users tried to add an image at the same time at the same index, the OT for list would order them (one might get index 0 and the other index 1 after transform, or vice versa).
  - The end result: both see the two images in the document.

- **Synchronization & Consistency:** Throughout this process, the system ensures that after each operation, all clients eventually converge to the same state. Even if messages arrive in different order (due to network), the transform logic accounts for it. For example, if network lag caused User2’s ingredient to reach User1 slightly late, by the time it arrives User1 might have local changes at later versions. But the client will know it missed something (maybe by version check or because the server included context) and can request a sync or the server’s transform already made it consistent. In practice, our server sends the authoritative sequence, so clients just apply in order.

- **Error Handling:** If one of User1’s operations fails (say they tried to delete a character that was already deleted by someone else), the transform would neutralize it (it becomes a no-op) and the server might not even send it out, or it sends a notice. The client SDK would adjust if needed. These cases are rare with proper transform.

  - If the server or network fails mid-session, the clients will attempt to reconnect. Suppose the server goes down after version 10. Clients keep any new ops they generate. When server restarts (with state up to v10 loaded from DB), the clients reconnect and perform a handshake: server says “current version is 10, state is X”. Clients see they have some unacknowledged ops from v10, so they resend them (with base 10). The server then processes them as if they happened after v10. This way, work done during a short disconnect can still be applied. If two clients both did offline edits, the first to reconnect would apply, the second’s would then transform or if truly conflicting (like both wrote completely different content in same place), one will overwrite or be appended depending on logic – at least no crash, though logically one edit might override the other in that scenario of simultaneous offline changes. Such cases and their outcomes will be documented.

- **Performance Considerations:** With each keystroke sending an op, our system must handle high frequency. We may implement some optimizations like **client-side buffering**: e.g. bundle multiple character inserts into one op if typing quickly. Or use compression in WebSocket frames. We will ensure that typical typing (which could be \~5-10 characters per second) is handled easily. The server can also broadcast efficiently (if many users, we might broadcast diffs or use a pub/sub broker in future). Testing on high latency and packet loss conditions will be done to ensure the experience remains fluid (perhaps using techniques like showing local echo immediately, which we do by applying local ops before acknowledgment).

### 6. Extensibility and Adapter Modules

To reiterate and detail the extensibility:

- **Network Transport Adapters:** The transport layer can be swapped. We provide `WebSocketTransport` by default. In future, one could implement, say, an `HttpPollingTransport` (if WebSockets not available) or integrate with other realtime services. For instance, a developer could use Ably or PubNub by writing a small adapter that translates RTCC ops to Ably messages and vice versa. Our core should be agnostic to how messages are delivered, as long as order is preserved per document and message types (ops, presence, etc.) can be conveyed.
- **Storage Adapters:** Similar for storage. Provide an interface `CollabStorageAdapter` with methods like `saveSnapshot(docId, data)`, `saveOp(docId, op)`, `loadLatest(docId)` etc. We’ll implement a basic `InMemoryStorage` (default, non-persistent) and perhaps `FileStorage` (just saves JSON to disk for dev/test). For production, we might include a reference implementation for a popular DB (e.g. `MongoStorageAdapter` using a MongoDB collection to store docs, or `PostgresStorageAdapter` using an upsert for current state and maybe separate table for ops). This makes it easy for developers to hook RTCC into their persistence of choice.
- **Framework Integrations:** We plan to release small helper packages:

  - For **React**: a set of React Hooks or Context providers to simplify using RTCC state in React. For example, a `<CollabProvider>` that provides context of the CollabClient, and hooks like `useSharedDocument(docId)` that manages the lifecycle (connecting, syncing) and returns state and operations. Also perhaps `usePresence(docId)` to get list of users. This will reduce boilerplate for React devs.
  - For **Flutter**: possibly a similar approach with InheritedWidget or other patterns to make it simple. Maybe a `CollabConsumer` widget that rebuilds when doc changes.
  - These are not core of the engine, but important for developer experience (DX). They can be developed alongside or after core but should be in scope to mention since goal is ease of use.

- **Editor Bindings:** While not immediate, we foresee providing or collaborating on bindings for rich text editors. E.g. hooking RTCC up to ProseMirror (which has its own collab module, but we could bypass it), or TipTap, or Slate.js. This likely involves translating between editor-specific change representations and our SharedText ops. It might be too detailed for v1 PRD, but definitely something to allow — that could be where community helps too. At least ensure our design doesn’t exclude such integration.
- **Custom Data Type Extensions:** If a developer has a very specific data structure not covered by our types (say a tree or graph), ideally they could implement their own OT type and plug it in. This is an advanced use-case. We could allow registration of custom types with their transform functions. For example, our library could let you define a type identifier and provide methods `transform(op1, op2)` and `apply(state, op)` for that type. Then if a document uses that type, the server and clients know how to handle it. This is similar to how ShareDB allows custom OT types. We will include this extensibility if possible, as it future-proofs the toolkit. Initially, though, we have our built-in types to cover common needs, which should be sufficient for most developers (text, list, map cover a wide range when combined).

### 7. Testing, Quality and Performance

Ensuring the reliability of RTCC is paramount (given the difficulties and the promise we’re making to developers). Key testing strategies:

- **Unit tests for OT Transformations:** We will write exhaustive tests for each data type’s OT logic. This includes applying random sequences of operations out-of-order and asserting final states equal. We can use known test cases from literature (many OT/CRDT papers provide examples of tricky scenarios). Also test boundary conditions (e.g. inserts at the very end of text concurrently with a delete at end, etc.). Every time we tweak the algorithm, run these to avoid regressions.

- **Multi-client Simulations:** Set up simulation tests where N simulated clients (in process) perform random operations on a shared document via the server logic, and at the end compare their states. This can catch any divergence. We can simulate network delay or reordering by randomizing op arrival order, etc. This kind of fuzz testing is vital for a collab engine.

- **Performance benchmarks:** We’ll benchmark common scenarios: typing speed (characters per second) and how the system handles it (both latency and CPU usage), large documents (e.g. a doc with 10k characters being edited), many concurrent small ops (like 5 users all making edits in different places). The aim is to identify bottlenecks and ensure the system can handle beyond typical usage to have a margin.

- **Memory usage:** Particularly in the browser, ensure our client doesn’t leak memory or grow unbounded. For example, if we keep an infinite log of ops on client, that’s bad – we should prune or compact. The server also should not let logs grow indefinitely (persist and truncate them). We’ll implement mechanisms like snapshotting to cap memory.

- **Cross-platform consistency:** We need to guarantee that the JS and Dart implementations of the algorithms produce identical results given the same inputs. We can do cross-language testing by recording a sequence of ops applied in JS and then replaying them in Dart (using a test) to ensure final state matches. Likewise, ensure any floating point or ordering quirks are aligned (we likely rely on integers and deterministic logic, so should be fine).

- **Documentation & Examples Testing:** All example code we publish should be tested (perhaps with integration tests or manually) to make sure it actually works with the library. Since developer experience is crucial, we want the out-of-the-box experience to be smooth.

## Future Enhancements (Post v1 Considerations)

While not part of the initial release, a few noteworthy enhancements could be planned for future versions:

- **True Offline Editing and CRDT Option:** To support scenarios where users might edit offline for extended periods and sync later without a central server always available, we could introduce a CRDT mode. This might involve using an existing CRDT library (like integrating Yjs data types under the hood for those who opt in) or developing a CRDT-based engine for certain data. This would allow peer-to-peer sync or at least resolve conflicts after offline merges more gracefully. However, as noted, CRDT for rich text still has limitations. A possible compromise is to offer offline caching and one-shot merge (like operational transform against a base version, similar to git merges, for when a client comes back online). This needs careful design and might align with a “3-way merge” strategy in some cases (as one HN commenter noted, sometimes a manual 3-way merge can be an option for less real-time use). In any event, exploring CRDT further could yield a hybrid engine combining OT (for active collaboration sessions) and CRDT (for offline background).

- **Rich Text Structure Support:** Expanding the toolkit to better handle _formatted text or XML/HTML_ structure. The current plan might treat rich text as plain text with markers, but a true rich text OT would handle element splitting, merging, etc. We might integrate with rich text models (like ProseMirror’s tree) and make it collaborative, or adopt tree-OT or even rich text CRDT approaches when they mature. This would let developers build fully-featured Google Docs or Notion-like editors with our core, supporting bold/italics, headers, lists, etc. Achieving this will require more complex algorithms (perhaps integrating with existing editor collab solutions in a pluggable way).

- **More Data Types:** For example, a **SharedGraph** or **SharedTree** type could be added for specific use cases (like mind maps or hierarchical data). Also, a **SharedCounter** (CRDT counter) or other CRDTs for specific purposes could be included if needed.

- **Optimistic UI Enhancements:** Features like **local undo/redo** support. Currently, if a user hits Ctrl+Z, we’d want to revert their last change. In an OT system, undo is not trivial (because the last change may have remote operations after it). We’d need to implement an undo stack that applies inverse ops and possibly treat them as new ops. This is doable and could be offered as a utility in the client SDK for text at least (CRDT handles undo via tombstones, but in OT we can track and explicitly undo). It’s a nice-to-have for completeness.

- **End-to-End Encryption:** As privacy demands grow, one future goal could be to allow that even the collaboration server cannot read the document content. Some research and projects have looked at performing OT or CRDT on encrypted data (often not possible unless operations themselves are encrypted and the server just relays). Perhaps a model where the server is dumb and just orders opaque operations, and clients do transforms, could be considered (this edges into P2P territory though). This is complex and would be later roadmap, but we note it for aligning with the idea that CRDT might allow such scenarios if implemented.

- **Analytics and Monitoring Tools:** Provide a dashboard or logs for developers to monitor collaboration sessions, see usage (how many concurrent users, operation throughput, etc.), and diagnose issues (like if a particular doc is experiencing high latency). This isn’t core to the engine but as a product feature can add value for teams using RTCC at scale.

- **Managed Service Offering:** Depending on strategy, we might offer RTCC as a hosted service (similar to how some companies offer Yjs hosting or Firebase does real-time). This would appeal to those who don’t want to run their own server. The PRD is primarily about the technology, but a note that packaging it as a cloud service with easy signup could be an avenue to drive adoption (with the open source library still available for self-hosters).

## Conclusion

The Real-Time Collaboration Core will fill a crucial gap for developers: providing a **reliable, flexible, and easy-to-use foundation** for building collaborative features into apps. By combining the **maturity of OT algorithms** (as used by Google, Microsoft, and others) with a **developer-friendly SDK** (inspired by the simplicity of tools like Yjs), RTCC enables even small teams to implement functionality that was previously considered out-of-reach due to complexity. We address the known pain points – complex conflict resolution, real-time network sync, multi-platform consistency – and package them into a solution where a developer can add live collaboration **as quickly as integrating a payment SDK or auth module**.

In delivering this product, we will pay special attention to correctness and consistency (to avoid the infamous divergence issues), performance in real-world scenarios, and the flexibility developers need to adapt the toolkit to their stack. The end result will be an **open-source collaboration engine** that can be the “secret sauce” behind many next-generation apps, powering use cases from co-editing and multiplayer productivity to live shared experiences, without each developer having to become an expert in distributed algorithms. By lowering the barrier to entry, RTCC could unlock a wave of more interactive, multi-user applications – making **real-time collaboration a standard feature** rather than a niche luxury.

**Sources:**

- TinyMCE Engineering Blog – _“To OT or CRDT, that is the question”_ (2020)
- Tag1 Consulting – _Evaluating real-time collaborative editing solutions_ (2021)
- Yjs – Official Documentation and Homepage
- TinyMCE Blog – _“Real-time collaboration is the new responsive design”_ (2021)
- Hacker News Discussions on CRDT vs OT
